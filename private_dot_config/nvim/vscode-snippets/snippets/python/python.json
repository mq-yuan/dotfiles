{
    "#!/usr/bin/env pythonX": {
        "prefix": "#env",
        "body": "#!/usr/bin/env python$0",
        "description": "Shebang line for the first python in PATH"
    },
    "uv_script": {
        "prefix": "#script",
        "body": [
            "# /// script",
            "# requires-python = \"${1:>=3.11}\"",
            "# dependencies = [",
            "# \t\"${2:numpy}\",",
            "# ]",
            "# ///"
        ],
        "description": "Tell uv the script dependencies"
    },
    "import": {
        "prefix": "import",
        "body": "import ${1:datetime}",
        "description": "Import a package or module"
    },
    "from ... import ...": {
        "prefix": "fromim",
        "body": "from ${1:pathlib} import ${2:Path}",
        "description": "Import individual objects directly into the callerâ€™s symbol table"
    },
    "__magic__": {
        "prefix": "__",
        "body": "__${1:init}__$0",
        "description": "Create magic method"
    },
    "self": {
        "prefix": "s",
        "body": "self.$0",
        "description": "Snippet to reference the self property in an object"
    },
    "if __name__ == __main__": {
        "prefix": "ifmain",
        "body": ["if __name__ == \"__main__\":", "\t${1:main()}"],
        "description": "Execute code if the file is executed directly"
    },
    "if": {
        "prefix": "if",
        "body": ["if ${1:condition}:", "\t${2:pass}"],
        "description": "if statement"
    },
    "elif": {
        "prefix": "elif",
        "body": ["elif ${1:expression}:", "\t${2:pass}"],
        "description": "elif statement"
    },
    "else": {
        "prefix": "else",
        "body": ["else:", "\t${1:pass}"],
        "description": "else statement"
    },
    "while": {
        "prefix": "while",
        "body": ["while ${1:condition}:", "\t${2:pass}"],
        "description": "while loop"
    },
    "for": {
        "prefix": "for",
        "body": ["for ${1:value} in ${2:iterable}:", "\t${3:pass}"],
        "description": "for loop"
    },
    "lambda": {
        "prefix": "lambda",
        "body": ["lambda ${1:parameter_list}: ${2:expression}"],
        "description": "lambda statement"
    },
    "Function": {
        "prefix": "def",
        "body": ["def ${1:fname}($2):", "\t${3:pass}"],
        "description": "Function definition"
    },
    "Method": {
        "prefix": "defs",
        "body": ["def ${1:mname}(self$2):", "\t${3:pass}"],
        "description": "Class method definition"
    },
    "device_parameter": {
        "prefix": "devicearg",
        "body": "device: Optional[Union[str, torch.device]] = None,$0",
        "description": "Add a typed torch device argument"
    },
    "get_intrinsic_from_fov": {
        "prefix": "intr_fov",
        "body": [
            "def _build_intrinsics_from_fov(",
            "    self, fovx_deg: float, fovy_deg: float",
            ") -> torch.Tensor:",
            "    \"\"\"Construct pixel intrinsics from horizontal and vertical FoV.",
            "",
            "    Args:",
            "        fovx_deg: Horizontal field of view in degrees.",
            "        fovy_deg: Vertical field of view in degrees.",
            "",
            "    Returns:",
            "        3x3 camera intrinsics matrix on the configured device and dtype.",
            "    \"\"\"",
            "    fx = 0.5 * self.width / math.tan(math.radians(fovx_deg) / 2.0)",
            "    fy = 0.5 * self.height / math.tan(math.radians(fovy_deg) / 2.0)",
            "    cx = 0.5 * self.width",
            "    cy = 0.5 * self.height",
            "    intr = torch.tensor(",
            "        [[fx, 0.0, cx], [0.0, fy, cy], [0.0, 0.0, 1.0]],",
            "        device=self.device,",
            "        dtype=self.dtype,",
            "    )",
            "    return intr$0"
        ],
        "description": "Build a 3x3 camera intrinsics matrix from FoV degrees"
    }
}
