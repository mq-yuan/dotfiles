{
    "color_space_utils": {
        "prefix": "py-color-space",
        "body": [
            "import numpy as np",
            "",
            "def srgb_to_linear(srgb):",
            "    \"\"\"",
            "    Convert sRGB color values to linear RGB color space.",
            "",
            "    This function transforms input sRGB values to linear RGB values using the",
            "    standard sRGB to linear conversion formula. The conversion handles values",
            "    differently based on whether they are below or above a threshold of 0.04045.",
            "",
            "    Parameters",
            "    ----------",
            "    srgb : array_like",
            "        Input array of sRGB values, typically in the range [0, 1]. Can be a scalar",
            "        or a multi-dimensional array.",
            "",
            "    Returns",
            "    -------",
            "    linear_rgb : ndarray",
            "        Array of linear RGB values with the same shape as the input `srgb`.",
            "        Values are in the linear color space, typically in the range [0, 1].",
            "",
            "    Notes",
            "    -----",
            "    The conversion uses the following piecewise function:",
            "    - For sRGB <= 0.04045: linear = sRGB / 12.92",
            "    - For sRGB > 0.04045: linear = ((sRGB + 0.055) / 1.055) ** 2.4",
            "",
            "    Examples",
            "    --------",
            "    >>> srgb_to_linear(0.5)",
            "    0.21404114",
            "    >>> srgb_to_linear(np.array([0.0, 0.5, 1.0]))",
            "    array([0.        , 0.21404114, 1.        ])",
            "    \"\"\"",
            "    mask = srgb <= 0.04045",
            "    linear_rgb = np.zeros_like(srgb)",
            "",
            "    linear_rgb[mask] = srgb[mask] / 12.92",
            "    linear_rgb[~mask] = ((srgb[~mask] + 0.055) / 1.055) ** 2.4",
            "",
            "    return linear_rgb",
            "",
            "",
            "def linear_to_srgb(linear_rgb):",
            "    \"\"\"",
            "    Convert linear RGB values to sRGB values.",
            "",
            "    This function applies the standard transformation from linear RGB color space",
            "    to sRGB color space, which is commonly used in digital imaging. The conversion",
            "    uses a piecewise function to handle different ranges of input values and ensures",
            "    the output is clamped to the valid sRGB range [0, 1].",
            "",
            "    Parameters",
            "    ----------",
            "    linear_rgb : array_like",
            "        Input array of linear RGB values, typically in the range [0, 1].",
            "        Can be a scalar, list, or NumPy array of any shape.",
            "",
            "    Returns",
            "    -------",
            "    numpy.ndarray",
            "        Array of sRGB values in the range [0, 1], with the same shape as the input.",
            "",
            "    Notes",
            "    -----",
            "    The conversion follows the sRGB specification:",
            "    - For linear RGB values <= 0.0031308, the output is scaled by 12.92.",
            "    - For linear RGB values > 0.0031308, the output is computed as",
            "      1.055 * (value^(1/2.4)) - 0.055.",
            "    - All output values are clipped to the range [0, 1].",
            "",
            "    Examples",
            "    --------",
            "    >>> linear_to_srgb(0.0)",
            "    0.0",
            "    >>> linear_to_srgb(1.0)",
            "    1.0",
            "    >>> linear_to_srgb(np.array([0.001, 0.5]))",
            "    array([0.01292, 0.73536...])",
            "    \"\"\"",
            "    mask = linear_rgb <= 0.0031308",
            "    srgb = np.zeros_like(linear_rgb)",
            "",
            "    srgb[mask] = linear_rgb[mask] * 12.92",
            "    srgb[~mask] = 1.055 * (linear_rgb[~mask] ** (1 / 2.4)) - 0.055",
            "",
            "    srgb = np.clip(srgb, 0, 1)",
            "",
            "    return srgb"
        ],
        "description": "sRGB to/from linear helpers"
    },
    "exr_io_utils": {
        "prefix": "py-exr-io",
        "body": [
            "import numpy as np",
            "import OpenEXR",
            "import Imath",
            "from typing import Optional, List",
            "",
            "def read_exr(exr_path: str, channel_names: Optional[List[str]] = None) -> np.ndarray:",
            "    \"\"\"Reads an OpenEXR file and returns its contents as a numpy array.",
            "",
            "    If channel_names is not provided, it attempts to detect standard RGB/RGBA",
            "    channels. If those are missing, it falls back to sorting all available",
            "    channels alphabetically to ensure deterministic behavior.",
            "",
            "    Args:",
            "        exr_path: Path to the EXR file.",
            "        channel_names: Optional list of channel names to read (e.g., ['Z'], ['R', 'G', 'B']).",
            "            If None, attempts to guess based on 'R', 'G', 'B', 'A'.",
            "",
            "    Returns:",
            "        np.ndarray: Array with shape (height, width, channels).",
            "",
            "    Raises:",
            "        IOError: If the file cannot be opened or channels are missing.",
            "    \"\"\"",
            "    file = None",
            "    try:",
            "        if not OpenEXR.isOpenExrFile(exr_path):",
            "            raise IOError(f\"File is not a valid EXR format: {exr_path}\")",
            "",
            "        file = OpenEXR.InputFile(exr_path)",
            "        header = file.header()",
            "        ",
            "        # Parse data window to get dimensions",
            "        dw = header[\"dataWindow\"]",
            "        width = dw.max.x - dw.min.x + 1",
            "        height = dw.max.y - dw.min.y + 1",
            "        ",
            "        available_channels = list(header[\"channels\"].keys())",
            "        ",
            "        # Determine which channels to read",
            "        if channel_names is None:",
            "            # Auto-detection logic",
            "            preferred_order = [\"R\", \"G\", \"B\", \"A\"]",
            "            matched_channels = [ch for ch in preferred_order if ch in available_channels]",
            "            ",
            "            if matched_channels:",
            "                target_channels = matched_channels",
            "            else:",
            "                # Fallback: Use all channels, sorted to ensure deterministic output",
            "                # (e.g., for Depth files containing only 'Z')",
            "                target_channels = sorted(available_channels)",
            "        else:",
            "            # Validate user requested channels",
            "            missing = [ch for ch in channel_names if ch not in available_channels]",
            "            if missing:",
            "                raise ValueError(f\"Channels {missing} not found in {exr_path}. Available: {available_channels}\")",
            "            target_channels = channel_names",
            "        ",
            "        # Define pixel type (FLOAT is standard for NumPy processing)",
            "        pixel_type = Imath.PixelType(Imath.PixelType.FLOAT)",
            "        ",
            "        # Read channels in bulk",
            "        # Note: file.channels returns a list of byte strings corresponding to the requested order",
            "        channel_data_strings = file.channels(target_channels, pixel_type)",
            "        ",
            "        # Pre-allocate output array",
            "        pixels = np.zeros((height, width, len(target_channels)), dtype=np.float32)", 
            "        ",
            "        for i, data_str in enumerate(channel_data_strings):",
            "            # frombuffer shares memory if possible, but reshape is needed",
            "            pixels[:, :, i] = np.frombuffer(data_str, dtype=np.float32).reshape(height, width)",
            "        ",
            "        return pixels",
            "        ",
            "    finally:",
            "        # Ensure file handle is closed",
            "        if file:",
            "            file.close()",
            "",
            "",
            "def save_exr(",
            "    exr_path: str, ",
            "    exr_image: np.ndarray, ",
            "    channel_names: Optional[List[str]] = None",
            ") -> None:",
            "    \"\"\"Saves a numpy array as an OpenEXR file.",
            "",
            "    Args:",
            "        exr_path: Path to save the EXR file.",
            "        exr_image: Image data with shape (height, width) or (height, width, channels).",
            "        channel_names: List of channel names corresponding to the last dimension.",
            "            Defaults to ['R', 'G', 'B', 'A'] or ['R'] depending on shape.",
            "            For depth maps, pass ['Z'].",
            "",
            "    Raises:",
            "        ValueError: If channel_count implies mismatched channel_names.",
            "    \"\"\"",
            "    # Ensure 3D shape: (H, W, C)",
            "    if exr_image.ndim == 2:",
            "        exr_image = exr_image[..., None]",
            "",
            "    height, width, channels = exr_image.shape",
            "    pixel_type = Imath.PixelType(Imath.PixelType.FLOAT)",
            "",
            "    # Determine channel names if not provided",
            "    if channel_names is None:",
            "        if channels == 1:",
            "            channel_names = [\"R\"] # Default to Red/Gray",
            "        elif channels == 3:",
            "            channel_names = [\"R\", \"G\", \"B\"]",
            "        elif channels == 4:",
            "            channel_names = [\"R\", \"G\", \"B\", \"A\"]",
            "        else:",
            "            # Fallback for arbitrary channel counts",
            "            channel_names = [f\"Channel_{i}\" for i in range(channels)]",
            "",
            "    if len(channel_names) != channels:",
            "        raise ValueError(",
            "            f\"Shape {exr_image.shape} has {channels} channels, \"",
            "            f\"but {len(channel_names)} names provided: {channel_names}\"",
            "        )",
            "",
            "    # Prepare Header",
            "    header = OpenEXR.Header(width, height)",
            "    header[\"channels\"] = {name: Imath.Channel(pixel_type) for name in channel_names}",
            "",
            "    # Prepare Data Dictionary",
            "    channel_data = {}",
            "    for i, name in enumerate(channel_names):",
            "        # Ensure float32 (OpenEXR expects 32-bit float bytes if pixel_type is FLOAT)",
            "        # Using ascontiguousarray ensures correct memory layout before tobytes",
            "        data_slice = np.ascontiguousarray(exr_image[:, :, i], dtype=np.float32)",
            "        channel_data[name] = data_slice.tobytes()",
            "",
            "    # Write file",
            "    out_file = None",
            "    try:",
            "        out_file = OpenEXR.OutputFile(exr_path, header)",
            "        out_file.writePixels(channel_data)",
            "    finally:",
            "        if out_file:",
            "            out_file.close()"
        ],
        "description": "Read and write OpenEXR files"
    },
    "tonemap_hdr_class": {
        "prefix": "py-tonemap-hdr",
        "body": [
            "import numpy as np",
            "",
            "",
            "class TonemapHDR(object):",
            "    \"\"\"",
            "        Tonemap HDR image globally. First, we find alpha that maps the (max(numpy_img) * percentile) to max_mapping.",
            "        Then, we calculate I_out = alpha * I_in ^ (1/gamma)",
            "        input : nd.array batch of images : [H, W, C]",
            "        output : nd.array batch of images : [H, W, C]",
            "    \"\"\"",
            "",
            "    def __init__(self, gamma=2.4, percentile=50, max_mapping=0.5):",
            "        self.gamma = gamma",
            "        self.percentile = percentile",
            "        self.max_mapping = max_mapping",
            "",
            "    def __call__(self, numpy_img, clip=True, alpha=None, gamma=True):",
            "        if gamma:",
            "            power_numpy_img = np.power(numpy_img, 1 / self.gamma)",
            "        else:",
            "            power_numpy_img = numpy_img",
            "        non_zero = power_numpy_img > 0",
            "        if non_zero.any():",
            "            r_percentile = np.percentile(power_numpy_img[non_zero], self.percentile)",
            "        else:",
            "            r_percentile = np.percentile(power_numpy_img, self.percentile)",
            "        if alpha is None:",
            "            alpha = self.max_mapping / (r_percentile + 1e-10)",
            "        tonemapped_img = np.multiply(alpha, power_numpy_img)",
            "",
            "        if clip:",
            "            tonemapped_img_clip = np.clip(tonemapped_img, 0, 1)",
            "",
            "        return tonemapped_img_clip.astype('float32'), alpha, tonemapped_img"
        ],
        "description": "Global HDR tonemapping helper"
    },
    "hdr_exposure_utils": {
        "prefix": "py-adjust-exposure",
        "body": [
            "import numpy as np",
            "",
            "",
            "def adjust_exposure(hdr_image, exposure_factor):",
            "    \"\"\"",
            "    Adjusts the exposure of an HDR image by applying an exponential scaling factor.",
            "",
            "    Parameters",
            "    ----------",
            "    hdr_image : numpy.ndarray",
            "        The input HDR (High Dynamic Range) image as a NumPy array. Expected to have",
            "        floating-point values representing linear radiance.",
            "    exposure_factor : float",
            "        The exposure adjustment factor in stops. Positive values increase brightness,",
            "        while negative values decrease brightness. A value of 0 results in no change.",
            "",
            "    Returns",
            "    -------",
            "    numpy.ndarray",
            "        The exposure-adjusted HDR image as a NumPy array with the same shape and dtype",
            "        as the input image.",
            "",
            "    Notes",
            "    -----",
            "    The exposure adjustment is performed by raising the input image values to the power",
            "    of 2 raised to the exposure factor (i.e., `2^exposure_factor`). This simulates the",
            "    effect of changing exposure in stops, where each stop represents a doubling or",
            "    halving of light intensity.",
            "",
            "    Examples",
            "    --------",
            "    >>> import numpy as np",
            "    >>> hdr_img = np.array([1.0, 2.0, 4.0])",
            "    >>> adjusted_img = adjust_exposure(hdr_img, 1.0)",
            "    >>> print(adjusted_img)",
            "    array([ 2.,  4.,  8.])",
            "",
            "    Raises",
            "    ------",
            "    ValueError",
            "        If `hdr_image` contains negative values, as HDR images are expected to have",
            "        non-negative radiance values.",
            "    TypeError",
            "        If `hdr_image` is not a NumPy array or if `exposure_factor` is not a numeric type.",
            "    \"\"\"",
            "    return hdr_image * np.power(2.0, exposure_factor)"
        ],
        "description": "Adjust HDR exposure"
    }
}
